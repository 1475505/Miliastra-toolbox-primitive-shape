# Shaper V6 技术方案

## 概述

Shaper 是一个**轮廓描边工具**，用基础图元（椭圆/矩形）沿图片主体轮廓进行"串珠"式拼接拟合。

> 想象一下：你有一个形状的轮廓线，你要沿着这条线串上一颗颗"珠子"（圆/椭圆/矩形），
> 让它们紧密排列、不超出轮廓边界，尽量覆盖住轮廓。这就是 Shaper 做的事。

### 核心目标

- ✅ 只描边轮廓，不填充内部
- ✅ 图元不超出轮廓（向内侧贴合）
- ✅ 图元尽可能大，无明显间隙
- ✅ 根据局部曲率自动选择图元类型和大小

---

## 使用方式

### 安装依赖

```bash
pip install opencv-python numpy shapely scipy
```

### 运行

```bash
python final_shaper.py <图片路径> [选项]
```

### 参数说明

| 参数 | 默认值 | 说明 |
|------|--------|------|
| `image_path` | `genshin.png` | 输入图片路径（支持 PNG/JPG/BMP/WebP） |
| `--min_size` | `6` | 最小图元尺寸（像素） |
| `--max_size` | `30` | 最大图元尺寸（像素） |
| `--spacing` | `0.9` | 间距系数（0.9 = 10% 重叠，越小重叠越多） |
| `-p, --precision` | `0.3` | 精度 0.0~1.0（低=偏好矩形+大拉伸，高=偏好椭圆+精细贴合） |
| `-o, --output_dir` | 输入图片目录 | 输出目录 |

### 使用示例

```bash
# 默认参数
python final_shaper.py genshin.png

# 高精度模式（更多椭圆，贴合更精细）
python final_shaper.py genshin.png -p 0.8

# 大图元粗拟合
python final_shaper.py genshin.png --min_size 10 --max_size 50 -p 0.2

# 密集小图元
python final_shaper.py genshin.png --min_size 3 --max_size 15 --spacing 0.85
```

### 输出文件

| 文件 | 说明 |
|------|------|
| `result_A_shapes_only.png` | 仅图元拼接效果图（BGRA，透明背景） |
| `result_B_overlay.png` | 图元拼接与原图叠加对比图 |
| `result_C_data.json` | 所有图元的坐标、尺寸、旋转角度等结构化数据 |
| `result_D_mask.png` | 前景 Mask 调试图 |

### 输出 JSON 格式

```jsonc
{
  "image_center": { "x": 155.0, "y": 122.0 },   // 图片中心坐标
  "image_size": { "width": 310, "height": 244 },
  "config": { ... },
  "elements_count": 289,
  "elements": [
    {
      "id": "0_3",
      "type": "ellipse",                          // 或 "rectangle"
      "center": { "x": 74.5, "y": 141.5 },       // 绝对坐标
      "relative_position": { "x": -80.5, "y": 19.5 }, // 相对图片中心
      "rotation": 45.0,                           // 旋转角度（度）
      "size": { "rx": 12.5, "ry": 8.0 }           // 椭圆半轴
      // 或 "size": { "width": 20.0, "height": 10.0 } // 矩形宽高
    }
  ]
}
```

---

## 整体流程（一图看懂）

```
输入图片 (PNG/JPG)
  │
  ▼
┌──────────────────────────────────────────────────┐
│  图像预处理                                        │
│  ├─ Alpha/灰度 → 二值 Mask (前景=白, 背景=黑)       │
│  ├─ 形态学去噪 (闭运算+开运算)                       │
│  ├─ 距离场 (每个前景点到最近边界的距离)                │
│  └─ 轮廓提取 (OpenCV findContours)                  │
└────────────────┬─────────────────────────────────┘
                 │
                 ▼
┌──────────────────────────────────────────────────┐
│  路径行走 (Path Walking) — 核心                     │
│  ├─ ① 曲率分析: 直线/弯曲/急弯 三档分类              │
│  ├─ ② 沿轮廓"走路": 一步步向前推进                   │
│  │   ├─ 在当前点: 二分查找最大能放的圆               │
│  │   ├─ 尝试拉伸成椭圆/矩形, 打分选最优              │
│  │   ├─ 放下这颗"珠子"                              │
│  │   └─ 往前走一步 (步长按短轴+曲率自动调整)          │
│  └─ ③ 走完一圈，得到一串珠子                         │
└────────────────┬─────────────────────────────────┘
                 │
                 ▼
┌──────────────────────────────────────────────────┐
│  后处理                                            │
│  ├─ 间隙检测: 两种策略找出未覆盖的"漏洞"             │
│  │   ├─ 像素法: 把所有珠子画出来，看哪里没被盖住      │
│  │   └─ 序列法: 看相邻珠子间距是否过大                │
│  ├─ 间隙填充: 在漏洞处补入珠子 (最多 5 轮)           │
│  ├─ 图元扩展: 保守地撑大每颗珠子 (最多 15%)          │
│  └─ 重叠抑制: 移除被大图元完全覆盖的冗余小图元        │
└────────────────┬─────────────────────────────────┘
                 │
                 ▼
           输出 4 个文件
```

---

## 核心算法详解

> 以下用尽量通俗的方式解释每一步，不需要任何编程基础也能看懂。

### 第一步：提取前景 Mask

**要解决的问题**：区分图片中的"主体"和"背景"。

**怎么做的**：
1. 如果图片有透明通道（PNG 常见）→ 透明的就是背景
2. 没有透明通道 → 看图片四周边缘是什么颜色（大概率是背景色），然后把和背景色差别大的像素标记为前景
3. 最后用 Otsu 算法（一种自动找最佳阈值的方法）把结果二值化：白=前景，黑=背景

### 第二步：构建距离场

**要解决的问题**：知道前景内部每个点"离边界有多远"。

**直觉理解**：想象前景区域是一座山，边界是海平面，距离场就是"海拔高度图"。越靠近中心（离边界越远）的点，海拔越高。

```
边界 ─────────────────── 边界
  1  2  3  4  5  4  3  2  1      ← 距离场值
       ↑中心（距离场值最大）
```

**为什么需要它**：放珠子时，珠子的半径不能超过它所在位置的距离场值，否则就会伸出边界。

### 第三步：曲率分析

**要解决的问题**：轮廓哪里是直线、哪里是弯道、哪里是急弯？

**直觉理解**：开车时，直路上可以加速（放大的长条图元），弯道要减速（放标准椭圆），急弯要急刹（放小圆）。

**具体做法**：
- 对轮廓点坐标做高斯平滑（去掉锯齿噪声）
- 用微积分公式算每个点的曲率 $\kappa = \frac{|x'y'' - y'x''|}{(x'^2 + y'^2)^{3/2}}$
- 按阈值分三档：直线 (κ < 0.012)、弯曲 (0.012~0.06)、急弯 (κ ≥ 0.06)

### 第四步：路径行走（核心！）

**要解决的问题**：沿轮廓放珠子。

**过程就像这样**：

```
你站在轮廓起点，面朝前方（切线方向），身体右侧是轮廓内部（法线方向）

每一步：
  1. 朝内部看（法线方向），找到"能放多大的珠子"
     → 用二分查找试不同半径，距离场告诉你极限
     → 圆心固定在法线方向上，紧贴轮廓（不会飘到内部深处）
  2. 试着拉伸
     → 直线段上试着把圆拉成椭圆/矩形（同样面积覆盖更多轮廓）
  3. 打分选最优
     → 得分 = 面积 × 包含度² × 紧凑度
  4. 放下珠子，向前走一步
     → 步长按短轴计算（不按长轴！），防止拉伸图元跳步过大
     → 急弯区步长 ×0.55（密排），直线区步长 ×1.15（稀排）
```

#### 关键设计：法线方向自适应探测

比较法线两侧的距离场值，选距离场值更大（更深入内部）的一侧。
- 探测距离自适应：取当前点距离场值的 40%（至少 2px）
- 窄轮廓（<4px 宽）也能正确判断方向

```
轮廓宽仅 4px 的情况:

  旧方法: ──→ 探测 2px ──→ 已穿过！方向判断错误 ✗
  现方法: ──→ 比较两侧 dist_map 值 ──→ 选 3.0 > 0.5 ──→ 正确 ✓
              左侧=3.0    右侧=0.5
```

#### 关键设计：弹性半径

- 二分查找范围扩展到 [1.5px, max_size/2]（不再强制 min_size/2 下限）
- 最终半径 = min(搜索结果, 距离场实际值)
- 保证即使在极窄轮廓处，圆也不会伸出边界

#### 关键设计：多维评分

椭圆：$\text{score} = \text{area} \times \text{containment}^2 \times \text{cp\_factor}$

矩形：$\text{score} = \text{area} \times (1 + \text{rect\_bonus}) \times \text{containment}^3 \times \text{cp\_factor}$

- **containment**（包含度）= 图元与轮廓的交集面积 / 图元面积，取平方/立方 → 强烈惩罚"擦边"候选
- **cp_factor**（紧凑度因子）= 低精度几乎不惩罚拉伸，高精度明显惩罚
- 矩形用 containment³（比椭圆的²更严格）：因为矩形角容易伸出弧形轮廓

#### 关键设计：步长基于短轴（V6 新增）

V5 的步长按长轴算，一个 5:1 拉伸的椭圆步长可达 45px，直接跳过弯角。

V6 改为 `min(长轴, 短轴 × 2.5)`，同一个椭圆步长约 22px，不再跳步。

### 第五步：间隙检测与填充

**要解决的问题**：路径行走后可能有一些"漏洞"没被珠子覆盖。

**双策略检测**：

1. **像素覆盖检测**：把所有珠子画到二值图上，沿轮廓检查未覆盖的连续段
2. **序列间距检测**：检查相邻珠子中心距是否过大（> 预期步长 × 1.5）

> 为什么需要策略 2？因为策略 1 靠"画像素"检测，膨胀处理可能把小间隙糊掉。
> 策略 2 从"珠子之间的拓扑关系"入手，不会被像素膨胀干扰。

**填充**：在每个间隙中均匀插入补充珠子，用该位置的真实曲率选择珠子类型，最多迭代 5 轮。

### 第六步：图元扩展（保守）

**要解决的问题**：路径行走时为了安全，珠子可能偏小。尝试温和地撑大。

- 先拉长轴，再拉短轴，两个方向都试
- 扩展倍率：最多 **1.15×**（V5 是 1.3×，更激进）
- 距离场验证阈值 **0.92**（V5 是 0.85，更宽松）
- 每次扩展后都做双重验证（Shapely 包含性 + 距离场边界采样），不超出轮廓才接受

### 第七步：重叠抑制

**要解决的问题**：间隙填充可能引入了和已有大图元完全重叠的小图元。

- 按面积从大到小排序
- 对每个小图元，检查是否被某个已接受的大图元覆盖超过 90%
- 用精确的 Shapely 交集面积计算（不走捷径，避免误删）

---

## 精度参数 (`-p`) 的影响

| 精度 | rect_bonus | aspect_limit | 效果 |
|------|-----------|-------------|------|
| 0.0 | 1.50 | 5.5 | 极致效率：大量矩形+极度拉伸，图元数最少 |
| 0.3 | 1.05 | 4.6 | **默认**：矩形为主，适度拉伸 |
| 0.5 | 0.75 | 4.0 | 均衡：椭圆/矩形各半 |
| 0.8 | 0.30 | 3.1 | 精细：椭圆为主，贴合度高 |
| 1.0 | 0.00 | 2.5 | 极致精度：几乎全椭圆，拉伸保守 |

---

## 依赖

| 库 | 用途 |
|----|------|
| `opencv-python` | 图像读写、Mask 提取、距离场、轮廓提取、渲染 |
| `numpy` | 数值计算、曲率微分、向量运算 |
| `shapely` | 椭圆/矩形多边形构造、面积交集包含性检验 |
| `scipy` | 高斯平滑（`gaussian_filter1d`），缺失时自动回退为均匀平均 |

---

## 文件结构

```
shaper/
├── final_shaper.py           # V6 主程序
├── _quality_check.py         # 质量诊断脚本 (覆盖率/溢出/间距分析)
├── _analyze.py               # JSON 输出简要分析
├── tech.md                   # 本技术方案文档
├── README.md                 # 原始需求文档
└── demo/
    ├── demo.png              # 测试图片
    ├── result_A_shapes_only.png
    ├── result_B_overlay.png
    ├── result_C_data.json
    └── result_D_mask.png
```

---

## 质量诊断

运行 `python _quality_check.py` 可以查看当前输出的质量指标：

```
=== V6 实测 (demo.png, p=0.3) ===
  前景覆盖率      94.9%
  溢出率          9.9%
  太远(>5px)      0.0%    ← 完全消除
  太浅(<-1px)     1.0%
  图元数          419
  间隙填充补入    94
```

关键指标含义：
- **前景覆盖率**：珠子覆盖了多少前景区域（越高越好，目标 >90%）
- **溢出率**：珠子伸出轮廓外的面积占比（越低越好，目标 <10%）
- **太远/太浅**：图元中心距离轮廓偏差（越少越好，0% 为理想）


